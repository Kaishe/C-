### 内存泄漏是什么

内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。



### C++内存泄漏的情况

#### 1. 在类的构造函数和析构函数中没有匹配的调用new和delete函数

​        两种情况下会出现这种内存泄漏：一是在堆里创建了对象占用了内存，但是没有显式的释放对象占用的内存；二是在类的构造函数中动态的分配了内存，但是在析构函数中没有释放内存或者没有正确的释放内存



#### 2. 没有正确的清楚嵌套的对象指针



#### 3. 释放对象数组时在delete中没有使用方括号

​        方括号是告诉编译器这个指针指向的是一个对象数组，同时也告诉编译器正确的对象地址值并调用对象的析构函数，没有方括号，指针会被默认为只指向一个对象，对象数组中的其他对象的析构函数就不会被调用，造成内存泄漏。

​        方括号中放一个比对象数组大小还大的数字，那么编译器就会调用无效对象（内存溢出）的析构函数，造成堆的崩溃，数字比对象数组大小小的话，编译器就不能调用足够多的析构函数，会造成内存泄漏



#### 4. 指向对象的指针数组不等同于对象数组

​        对象数组是指数组中存放的是对象，只需要delete []p，即可调用对象数组中的每个对象的析构函数释放空间

​        指向对象的指针数组是指数组中存放的是指向对象的指针，不仅要释放每个对象的空间，还要释放每个指针的空间，delete []p只是释放了每个指针，但是没有释放对象的空间，应该先通过一个循环将每一个对象释放，然后再把指针释放



#### 5.缺少拷贝构造函数

​        两次释放相同的内存可能会造成堆的崩溃

​        按值传递会调用（拷贝）构造函数，引用传递不会调用

​        在C++中，如果没有定义拷贝构造函数，编译器会调用默认的拷贝构造函数，会逐个成员拷贝的方式来复制数据成员，如果是以逐个成员拷贝的方式来复制指针，将被定义为将一个变量的地址赋给另一个变量。这种隐式的指针复制结果就是两个对象拥有指向同一个动态分配的内存空间的指针。当释放第一个对象的时候，它的析构函数就会释放与该对象有关的动态分配的内存空间，而释放第二个对象时，它的析构函数会释放相同的内存，因此造成堆的崩溃

​        因此，如果一个类里面有指针成员变量，需要显式的写出拷贝构造函数和重载赋值运算符



#### 6.缺少重载赋值运算符

​        与上相同，如果类的大小是可变的，就会造成内存泄漏



#### 7.运算符重载函数的返回值不是类型的引用，而应该是类型的返回值，即不是int&而是int



#### 8.没有将基类的析构函数定义为虚函数

### 解决方法

最有效的方法是使用智能指针，智能指针可以自动删除分配的内存

C++提供了unique_ptr  shared_ptr  weak_ptr几种智能指针